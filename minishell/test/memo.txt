・readlineを含むときのコンパイル方法
　gcc -lreadline <file>

・.my_historyにreadlineで読み込んだテキストが書き込まれている


Function: void rl_clear_history (void)
Clear the history list by deleting all of the entries,
in the same manner as the History library’s clear_history() function.
This differs from clear_history because it frees private data Readline saves in the history list.

Function: int rl_on_new_line (void)
Tell the update functions that we have moved onto a new (empty) line,
usually after outputting a newline.

Function: void rl_replace_line (const char *text, int clear_undo)
Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible.
If clear_undo is non-zero, the undo list associated with the current line is cleared.

Function: void rl_redisplay (void)
Change what’s displayed on the screen to reflect the current contents of rl_line_buffer.

add_history (line);
If you want the user to be able to get at the line later, (with C-p for example),
you must call add_history() to save the line away in a history list of such lines.




<<進捗>>
4/29
とりあえず、コマンド一つ、パイプなどを考慮していない。
unset PATHの時に、pwd,cdなどは、bashでは実行できるはずだが、ほかのコマンド同様に
	bash: pwd: No such file or directory
と表示されてしまう
cd は実行はできるが、ディレクトリは移動できていない
スペースは無視して実行できるが、タブが入るとcommand not foundなどになって実行できない。
改行は、bashでもcommand not foundになるっぽいからスペースとタブだけでいいのかも？
add_historyはどこに保存されているのかわからないから、.my_historyを作ったがいらないっぽい
tokenizarでスペース、タブ、改行で区切ってからpipex関数に入るようにする。（tokenizerはまだやってない）

4/30
builtin commandのうち、cdのみ実行ずみ、cd でホームディレクトリにも移動できるようにしてある。
test.sh 作成したけど、よくわかんない。status NGになってしまう。
*dprintfは実装したほうがいいらしい
*printfよりもputstrのほうがいい
echo -n 実装済み、　\は対応する？ ※bashでは\nはn、\\nは\nが表示される。
何か文字を打った後に、ctrl+Dを押しても終了しない
